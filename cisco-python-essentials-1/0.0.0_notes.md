## Index
##### 1. [[#Computers are binary]]
##### 2. [[#Language elements]]
##### 3. [[#Actions that form a Program]]
##### 4. [[#Python is]]
##### 5. [[#Python Data Types]]
##### 6. [[#Python Keywords]]
##### 7. [[#Operators by priority]]
##### 8. [[#Functions]]
##### 9. [[#Methods]]
##### 10. [[#Error Types]]
##### 11. [[#Exceptions]]
##### 12. [[#Cool things to keep in mind]]
##### 13. [[#Best practices]]
##### 14. [[#Remember]]
##### 15. [[#How to read Python]]
##### 16. [[#Examples]]

#### Computers are binary
The name 'boolean' comes from George Boole (1815-1864), the author of the fundamental work, _The Laws of Thought_, which contains the definition of **Boolean algebra** ‒ a part of algebra which makes use of only two distinct values: `True` and `False`, denoted as `1` and `0`.

A programmer writes a program, and the program asks questions. A computer executes the program, and provides the answers. The program must be able to react according to the received answers.

Fortunately, computers know only two kinds of answers:

- Yes, this is true;
- No, this is false.

You'll never get a response like: _I don't know_ or _Probably yes, but I don't know for sure_.

False is when all the bits are reset;
True is when at least one bit is set.

---
#### Language elements
1. Alphabet
2. Lexis
3. Syntax
4. Semantics

---
#### Actions that form a Program
1. Input
2. Processing
3. Output

---
#### Compilation vs Interpretation
1. COMPILATION
- Doesn't need compiler to work
- Usually faster, but can't be easily edited
- May take time to fully compile
- Source code is hidden from the user and can't be shared easily as it needs to be compiled for each kind of architecture

2. INTERPRETATION
- Needs interpreter to work
- Usually slower than compiled because the computer resources are shared among the source program and the interpreter itself
- Happens instantly, line by line
- Source code is easily shareable and works anywhere there is a interpreter

---
#### Python is
- a high-level programming language with dynamic semantics
- an interpreted programming language
- object-oriented
- used for general-purpose programming
- easy and intuitive, understandable, suitable for everyday tasks
- easy to learn, teach, use, understand, obtain

---
#### Python Data Types
- Integers
- Floats
- Strings
- Boolean values
- None: is a `NoneType` object, and it is used to represent **the absence of a value**

---
#### Python Keywords
##### Known
```python
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

False, True # boolean values
None # Null equivalent in python
if, elif, else # conditions
pass # empty instruction to bypass syntax demands of if, elif, else, while, for, etc
while, for, break, continue, else # loops
in # most often used in for loops but also used in decisions
and, or, not # logical operators
del # instruction used to remove a list element



, is - ?
def, return # functions
import, from, as # working with modules and libraries
try, except, finally, raise # validation
with, as # working with files

```

##### Need to learn
'assert', 'class', 'del', 'global', 'lambda', 'nonlocal', 'yield'

---
#### Operators by priority
- **Basic:** `**`; unary `+`, unary `-`; `*`, `/`, `//`, `%`; binary `+`, binary `-`
- **Shift**: `<<` and `>>` (pair of digraphs)
- **Comparison/Relational**: `>` (greater than), `>=` (greater than or equal to), `<` (less than), `<=` (less than or equal to); `==` (equal to), `!=` (not equal to)
- **Logical**: `not` (negation); `and` (conjunction); `or` (disjunction)
- **Assignment:** `=`
- **Shortcut**: `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`


- **Bitwise** (abbreviated form): `~` (negation); `&` (conjunction); `^` (XOR); `|` (disjunction)
> [!NOTE]- More about bitwise operations
> - **Bitwise**: allow you to **manipulate single bits of data**. The arguments of these operators **must be integers**. The difference in the operation of the logical and bit operators is important: **the logical operators do not penetrate into the bit level of its argument**. They're only interested in the final integer value. Bitwise operators are stricter: they deal with **every bit separately**.
> 	- `&` (ampersand) ‒ bitwise conjunction;
> 	- `|` (bar) ‒ bitwise disjunction;
> 	- `~` (tilde) ‒ bitwise negation;
> 	- `^` (caret) ‒ bitwise exclusive or (xor).
> 
> Bitwise operations (&, |, and ^)
> 
> | Argument A | Argument B | A & B | A \| B | A ^ B |
> | ---------- | ---------- | ----- | ------ | ----- |
> | 0          | 0          | 0     | 0      | 0     |
> | 0          | 1          | 0     | 1      | 1     |
> | 1          | 0          | 0     | 1      | 1     |
> | 1          | 1          | 1     | 1      | 0     |
> 
> Bitwise operations (~)
>  
> | Argument | ~ Argument |
> | -------- | ---------- |
> | 0        | 1          |
> | 1        | 0          |
> 
> Let's make it easier:
> - `&` requires exactly two 1s to provide 1 as the result;
> - `|` requires at least one 1 to provide 1 as the result;
> - `^` requires exactly one 1 to provide 1 as the result.
> 
> Examples:
> ```python
> i = 15
> j = 22
> 
> ### Conjunction:
> log = i and j # log == True
> 
> bit = i & j # bit == 6
> # because
> #   i: 00000000000000000000000000001111
> #   j: 00000000000000000000000000010110
> # bit: 00000000000000000000000000000110
> 
> ### Negation:
> logneg = not i # logneg == False
> 
> bitneg = ~i # bitneg == -16
> # because
> #      i: 00000000000000000000000000001111
> # bitneg: 11111111111111111111111111110000
> # If we interpret that as an **unsigned** 8-bit number, it would be **240**.
> # But Python integers are **signed** (they can be negative), and it uses
> # **two’s complement** logic to handle signs conceptually.
> # So to find its decimal value:
> # 1. Invert the bits
> #	 → `00000000000000000000000000001111`
> # 2. Add 1  
> #    → `00000000000000000000000000010000` = 16
> # 3. Then put the negative sign:
> #    → `-16`
> ```
> 
> You can use bitwise operators to manipulate single bits of data. The following sample data:
> 
> - `x = 15`, which is `0000 1111` in binary,
> - `y = 16`, which is `0001 0000` in binary.
> 
> will be used to illustrate the meaning of bitwise operators in Python. Analyze the examples below:
> 
> - `&` does a _bitwise and_, e.g., `x & y = 0`, which is `0000 0000` in binary,
> - `|` does a _bitwise or_, e.g., `x | y = 31`, which is `0001 1111` in binary,
> - `˜` does a _bitwise not_, e.g., `˜ x = 240`\*, which is `1111 0000` in binary,
> - `^` does a _bitwise xor_, e.g., `x ^ y = 31`, which is `0001 1111` in binary,
> - `>>` does a _bitwise right shift_, e.g., `y >> 1 = 8`, which is `0000 1000` in binary,
> - `<<` does a _bitwise left shift_, e.g., `y << 3 = 128`, which is `1000 0000` in binary.
> 
> * -16 (decimal from signed 2's complement) -- read more about the [Two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) operation.
>
> #### Binary left shift and binary right shift
> 
> Python offers yet another operation relating to single bits: **shifting**. This is applied only to **integer** values, and you mustn't use floats as arguments for it.
> 
> You already apply this operation very often and quite unconsciously. How do you multiply any number by ten? Take a look:
> 
> 12345 × 10 = 123450
> 
> As you can see, **multiplying by ten is in fact a shift** of all the digits to the left and filling the resulting gap with zero.
> 
> Division by ten? Take a look:
> 
> 12340 ÷ 10 = 1234
> 
> Dividing by ten is nothing but shifting the digits to the right.
> 
> The same kind of operation is performed by the computer, but with one difference: as two is the base for binary numbers (not 10), **shifting a value one bit to the left thus corresponds to multiplying it by two**; respectively, **shifting one bit to the right is like dividing by two** (notice that the rightmost bit is lost).
> 
> The **shift operators** in Python are a pair of **digraphs**: `<<` and `>>`, clearly suggesting in which direction the shift will act.
> 
> ```
> value << bits
> value >> bits
>  
> ```
> 
> **The left argument of these operators is an integer value whose bits are shifted. The right argument determines the size of the shift.**
> 
> It shows that this operation is certainly not commutative.
> 
> The priority of these operators is very high. You'll see them in the updated table of priorities, which we'll show you at the end of this section.
> 
> Take a look at the shifts in the editor window.
> 
> ```python
> var = 17
> var_right = var >> 1
> var_left = var << 2
> print(var, var_left, var_right)
> 
> ```
> 
> The final `print()` invocation produces the following output:
> 
> ```Output
> 17 68 8
> ```
> 
> Note:
> 
> - `17 >> 1` → `17 // 2` (**17** floor-divided by **2 to the power of 1**) → `8` (shifting to the right by one bit is the same as integer division by two)
> - `17 << 2` → `17 * 4` (**17** multiplied by **2 to the power of 2**) → `68` (shifting to the left by two bits is the same as integer multiplication by four)

| Priority | Operator                                                                                                                                                                                    | Notes  | Type                                                                                  |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ | ------------------------------------------------------------------------------------- |
| 1        | <code>~</code>, <code>+</code>, <code>-</code>                                                                                                                                              | unary  | tilde (Bitwise Negation), unary plus/minus (Arithmetic)                               |
| 2        | <code>**</code>                                                                                                                                                                             |        | exponentiation (Arithmetic)                                                           |
| 3        | <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>                                                                                                                             |        | multiplication, division, floor/integer division, modulo (Arithmetic)                 |
| 4        | <code>+</code>, <code>-</code>                                                                                                                                                              | binary | binary plus/minus (Arithmetic)                                                        |
| 5        | <code><<</code>, <code>>></code>                                                                                                                                                            |        | pair of digraphs (Bitwise Shift)                                                      |
| 6        | <code><</code>, <code><=</code>, <code>></code>, <code>>=</code>                                                                                                                            |        | less than, less than or equal to, greater than, greater than or equal to (Comparison) |
| 7        | <code>==</code>, <code>!=</code>                                                                                                                                                            |        | equality, inequality (Comparison)                                                     |
| 8        | <code>&</code>                                                                                                                                                                              |        | ampersand (Bitwise Conjunction)                                                       |
| 9        | <code>^</code>                                                                                                                                                                              |        | caret (Bitwise Exclusive or)                                                          |
| 10       | <code>\|</code>                                                                                                                                                                             |        | bar (Bitwise Disjunction)                                                             |
| 11       | <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&=</code>, <code>^=</code>, <code>\|=</code>, <code>>>=</code>, <code><<=</code> |        | Assignment Operator + Shortcuts/Abbreviated Forms                                     |

| Priority | Operators            | Description                                      |
| -------- | -------------------- | ------------------------------------------------ |
| 1        | `+`, `-` (unary)     | Unary plus/minus (e.g., `-x`, `+y`)              |
| 2        | `**`                 | Exponentiation                                   |
| 3        | `*`, `/`, `//`, `%`  | Multiplication, division, floor division, modulo |
| 4        | `+`, `-` (binary)    | Binary addition and subtraction                  |
| 5        | `<`, `<=`, `>`, `>=` | Comparison operators                             |
| 6        | `==`, `!=`           | Equality and inequality                          |

---
#### Conditional Execution/Instruction/Statement
There's at least two possibilities on how to make use of the boolean answers the computer gives to comparison questions:
1. Memorize it (store it in a variable) and make use of it later
2. Use the answer you get to make a decision about the future of the program

---
#### Functions
##### A function may
1. cause some effect. Ex.: print()
2. or evaluate a value. Ex.: sqrt()
- have parameters to accept (positional/keyword) arguments

##### Known Functions
`print()`, `round()`, `input()`, `int()`, `float()`, `str()`, `max()`, `min()`, `range()` (`float`), `time.sleep()`, `len()` (lists)

##### Important things to know about functions:
- `print()` can work with octal and hex values: `print(0o10)` equals `8` while `print(0x10)` equals `16`
	- Note: `oct()` and `hex()` can be used for type casting
- `round()`: signature `round(number[, ndigits])`, numbers **less than .5** round down, numbers **greater than .5** round up, but numbers **exactly at .5 are an exception**: Python uses Round Half to Even rounding.

> [!EXAMPLE]- Demonstration
> ```python
> >>> x = 10.501
> >>> round(x, -1) # nearest multiple of 10
> 10.0
> >>> round(x) # nearest integer
> 11
> >>> round(x, 0) # same but with the floating point
> 11.0
> >>> round(x, 1) # 1 decimal place
> 10.5
> >>> round(x, 2) # 2 decimal places
> 10.5
> >>> round(x, 3) # 3 decimal places
> 10.501
> >>> round(x, 4) # 4 decimal places
> 10.501
> 
> >>> x = -10.501
> >>> round(x, -1)
> -10.0
> >>> round(x, 0)
> -11.0
> >>> round(x, 1)
> -10.5
> >>> round(x, 2)
> -10.5
> >>> round(x, 3)
> -10.501
> >>> round(x, 4)
> -10.501
> ```

> [!NOTE]- Round Half to Even (Banker's Rounding, IEEE 754 Standard)
> 
> `.5` values round toward the **nearest even integer**, not always up, to keep results statistically unbiased across large datasets.
> 
> |Value|Nearest Integers|Rounded To|Reason|
> |:-:|:-:|:-:|:--|
> |-12.5|[-12] , -13|**-12**|-12 is even|
> |-11.5|-11 , [-12]|**-12**|-12 is even|
> |-10.5|[-10] , -11|**-10**|-10 is even|
> |-9.5|-9 , [-10]|**-10**|-10 is even|
> |-8.5|[-8] , -9|**-8**|-8 is even|
> |-7.5|-7 , [-8]|**-8**|-8 is even|
> |-6.5|[-6] , -7|**-6**|-6 is even|
> |-5.5|-5 , [-6]|**-6**|-6 is even|
> |-4.5|[-4] , -5|**-4**|-4 is even|
> |-3.5|-3 , [-4]|**-4**|-4 is even|
> |-2.5|[-2] , -3|**-2**|-2 is even|
> |-1.5|-1 , [-2]|**-2**|-2 is even|
> |-0.5|[0] , -1|**0**|0 is even|
> |0.5|[0] , 1|**0**|0 is even|
> |1.5|1 , [2]|**2**|2 is even|
> |2.5|[2] , 3|**2**|2 is even|
> |3.5|3 , [4]|**4**|4 is even|
> |4.5|[4] , 5|**4**|4 is even|
> |5.5|5 , [6]|**6**|6 is even|
> |6.5|[6] , 7|**6**|6 is even|
> |7.5|7 , [8]|**8**|8 is even|
> |8.5|[8] , 9|**8**|8 is even|
> |9.5|9 , [10]|**10**|10 is even|
> |10.5|[10] , 11|**10**|10 is even|
> |11.5|11 , [12]|**12**|12 is even|
> |12.5|[12] , 13|**12**|12 is even|
> 

- `range()` (<code>range(start, stop[, step])</code>) works both ways: `range(1, 5, 1)` equals `1234` while `range(1, 5, -1)` equals `5432`

#### Methods
A **method is a specific kind of function** ‒ it behaves like a function and looks like a function, but differs in the way in which it acts, and in its invocation style.

A **function doesn't belong to any data** ‒ it gets data, it may create new data and it (generally) produces a result.

A method does all these things, but is also able to **change the state of a selected entity**.

**A method is owned by the data it works for, while a function is owned by the whole code**.

This also means that invoking a method requires some specification of the data from which the method is invoked.

It may sound puzzling here, but we'll deal with it in depth when we delve into object-oriented programming.

In general, a typical function invocation may look like this:

```
result = function(arg) 
```

The function takes an argument, does something, and returns a result.

A typical method invocation usually looks like this:

```
result = data.method(arg) 
```

Note: the name of the method is preceded by the name of the data which owns the method. Next, you add a **dot**, followed by the **method name**, and a pair of **parenthesis enclosing the arguments**.

The method will behave like a function, but can do something more ‒ it can **change the internal state of the data** from which it has been invoked.

This is an essential issue right now, as we're going to show you how to add new elements to an existing list. This can be done with methods owned by all the lists, not by functions.

##### Known Methods:
```python
time.sleep() # `sleep()` is a **function** defined in the `time` module, and when you call it as `time.sleep()`, it behaves like a method of that module.
list.append(value) # It takes its argument's value and puts it **at the end of the list** which owns the method.
list.insert(location, value) # it can add a new element **at any place in the list**, not only at the end

```

---

#### Error Types
- `AttributeError` happens when you try to use a property or method that doesn’t exist for an object. Example: `number = 42` then `number.append(5)`
- `IndexError` happens when you try to access a position in a list (or similar structure) that doesn’t exist. Example: `my_list = [10, 20, 30]` then `print(my_list[5])`
- `NameError` happens when you try to use a variable or function name that hasn’t been defined. Example: `print(score)`when `score`hasn't been defined yet.
- `TypeError` happens when you use a value of the wrong type for an operation. Example: `print("Age: " + 25)`
- `ValueError` happens when a function gets the right type of input, but the value doesn’t make sense. Example: `int("hello")` → `"hello"` is a string, but not a valid number.
#### Exceptions
- `KeyboardInterrupt` happens when you manually stop a running Python program—usually by pressing `Ctrl+C`.

---
#### Cool things to keep in mind
- `print()` can handle octals and hexadecimals
- `0.4` can be written as `.4` and `4.0` can be written as `4.` because you can omit zero when it is the only digit in front of or after the decimal point
- `300000000` or `3 x 10⁸` scientific notation is written as `3e8` or `3E8` in Python. Ex.: `6.62607E-34`
    - Note: the exponent (the value after the E) has to be an integer; the base (the value in front of the E) may be either an integer or a float.
- `print('I\'m Monty Python.')` or `print("I'm Monty Python.")`
- `6 // 3` equals `2` (integer) because only when an integer is divided by an integer with `//` (integer/floor division) it results in an integer. Any regular divisions (`/`) or a floor division involving a float operand WILL result in a float because anything involving a float results in a float, even addition, subtraction, multiplication and exponentiation. Even an integer exponentiation may result in a float: `4 ** -1` equals `0.25`. However, for `//`, anything after the floating point becomes `0`. Ex.: `10 / 3` equals 3.333... but `10 // 3` equals `3`
- `%` (Remainder/Modulo) always results in a integer (or a float with `.0` if either operand is a float) because it results the remainder left after the integer division

| >OPERATION     | INT & INT      | INT & FLOAT     | FLOAT & INT      | FLOAT & FLOAT      |
| -------------- | -------------- | --------------- | ---------------- | ------------------ |
| Addition       | 1 + 1 = 2      | 1 + 1.0 = 2.0   | 1.5 + 1 = 2.5    | 1.5 + 1.0 = 2.5    |
| Subtraction    | 1 - 1 = 0      | 1 - 1.0 = 0.0   | 1.5 - 1 = 0.5    | 1.5 - 1.0 = 0.5    |
| Multiplication | 2 * 2 = 4      | 2 * 2.0 = 4.0   | 2.5 * 2 = 5.0    | 2.5 * 2.0 = 5.0    |
| Division       | 2 / 2 = 1.0    | 2 / 2.0 = 1.0   | 2.5 / 2 = 1.25   | 2.5 / 2.0 = 1.25   |
| Floor Division | 2 // 2 = 1     | 2 // 2.0 = 1.0  | 2.5 // 2 = 1.0   | 2.5 // 2.0 = 1.0   |
| Modulo         | 12 % 5 = 2     | 12 % 4.5 = 3.0  | 12.0 % 5 = 2.0   | 12.5 % 4.5 = 3.5   |
| Exponentiation | 4 ** 2 = 16    | 4 ** 2.0 = 16.0 | 4.5 ** 2 = 20.25 | 4.5 ** 2.0 = 20.25 |
| Extra          | 4 ** -1 = 0.25 |                 |                  |                    |
- `2 % 4` equals 2 because 2 - 4 * (2 // 4) = 2 - 4 * 0 = 2 - 0 = 2
- `2 % -4` equals -2 because 2 - (-4) * (2 // -4) = 2 - (-4) * -1.0 = 2 - 4 = -2
- `9 ** 0.5` evaluates the square root of 9
- `9 * 0.1` evaluates 10% of 9
- `9 * 1.1` evaluates 9 + 10% of 9
- `input()` can be used without an argument
- `2 == 2.` | `2. == 2` is True
- `while number:` is the same as `while number != 0:`
- `if number % 2:` is the same as `if number % 2 == 1:`
- Data Types and boolean values:
```Python
print(
f'''Integer: 1 - {bool(1)} | 0 - {bool(0)} | -1 - {bool(-1)}
Floating point: 1.0 - {bool(1.0)} | 0.0 - {bool(0.0)} | 0.1 - {bool(0.1)} | -1.0 - {bool(-1.0)}
String: 'Test' - {bool('Test')} | '' - {bool('')} | '0' - {bool('0')}
NoneType: None - {bool(None)}
List: [0, 0.0, '', False] - {bool([0, 0.0, '', False])} | [] - {bool([])}
Tuple: (0, 0.0, '', False) - {bool((0, 0.0, '', False))} | () - {bool(())}
Set: {{0, 0.0, '', False}} - {bool({0, 0.0, '', False})} | {{}} - {bool({})} | set() - {bool(set())}
''')

a = False
if a is not None:
    print(f"{a} is not NULL")
if a:
    print(f"{a} is not NULL, nor EMPTY (e.g.: '', 0, 0.0, False)")

```

- Python `==` vs `is`:
	- **`==`** → checks **value equality**
	- **`is`** → checks **object identity** (same memory location)
	- For booleans, always use `is` when checking against `True` or `False` **after using `bool()`**.
	- Never use `is` for numbers — only for singletons like `None`, `True`, `False`.

| Expression         | Result                    | Explanation                                                   |
| ------------------ | ------------------------- | ------------------------------------------------------------- |
| `0 == False`       | True                      | Values are equal (`False` is int subclass with value 0)       |
| `0 is False`       | False                     | Different objects/types (`int` vs `bool`)                     |
| `bool(0) == False` | True                      | Value equality, 0 converts to `False`                         |
| `bool(0) is False` | True                      | `bool()` returns the canonical `False` object → same identity |
| `None == None`     | True                      | Values are equal                                              |
| `None is None`     | True                      | Identity check → same object in memory                        |
| `len([]) == 0`     | True                      | `len([])` returns 0, equal to 0                               |
| `len([]) is 0`     | False (unsafe to rely on) | Different objects, `is` checks identity                       |
| `len([]) == False` | True                      | 0 is treated as False in boolean context                      |
| `len([]) is False` | False                     | different object types (`int` vs `bool`)                      |
| `len([]) is None`  | False                     | different object types                                        |
- `~4` equals `-5` because of two's complement: - (4 + 1)
- `17 >> 1` → `17 // 2` (**17** floor-divided by **2 to the power of 1**) → `8` (shifting to the right by one bit is the same as integer division by two)
- `17 << 2` → `17 * 4` (**17** multiplied by **2 to the power of 2**) → `68` (shifting to the left by two bits is the same as integer multiplication by four)
- `del numbers[1]` removes the 2nd element of a list while `del my_list` deletes the whole list
- An element with an index equal to -1 is **the last one in the list**.. Ex.: `numbers[-1]`
- `numbers.append(4)` adds the number `4` at the end of the list
- `numbers.insert(0, 222)` adds the number `222` to the index `0` of the list
- How to reverse the order of certain pairs of numbers in a list:
```python
for i in range(length // 2):
    my_list[i], my_list[length - i - 1] = my_list[length - i - 1], my_list[i]
 
print(my_list)
```
 
 Note:
  - we've assigned the `length` variable with the current list's length (this makes our code a bit clearer and shorter)
 - we've launched the `for` loop to run through its body `length // 2 times` (this works well for lists with both even and odd lengths, because when the list contains an odd number of elements, the middle one remains untouched)
 - we've swapped the ith element (from the beginning of the list) with the one with an index equal to `(length - i - 1)` (from the end of the list); in our example, for `i` equal to `0` the `(length - i - 1)` gives `4`; for `i` equal to `1`, it gives `3` ‒ this is exactly what we needed.

---
#### Best practices:
- Comments: Comments are very important. They are used not only to make your programs **easier to understand**, but also to **disable those pieces of code that are currently not needed** (e.g., when you need to test some parts of your code only, and ignore others).
- Variable names: Whenever possible and justified, you should give self-commenting names to variables, e.g., if you're using two variables to store the length and width of something, the variable names `length` and `width` may be a better choice than `myvar1` and `myvar2`.
- It's good to **describe** each important piece of code with comments, use **self-commenting** and **readable** (non-confusing) variable names, and sometimes it's better to **divide your code** into named pieces (e.g., functions). In some situations, it's a good idea to write the steps of computations in a clearer way.
- Don't feel obliged to code your programs in a way that is always the shortest and the most compact. Readability may be a more important factor. Keep your code ready for a new programmer.
- **Using the same name of a built-in Python function as a variable name would generally be considered bad practice**.

---
#### Remember:
- function:
    - positional argument: arguments passed in the positional way which means the meaning of the argument is dictated by its position
    - keyword argument:
        - the meaning of these arguments is taken not from its location (position) but from the special word (keyword) used to identify them
        - it consists of three elements: a **keyword** identifying the argument; an **equal sign** and a **value** assigned to the argument. Any keyword arguments have to be put **after the last positional argument**
- literal: data whose values are determined by the literal itself. Ex.: `123` vs `c`. `123` is *one hundred twenty three*. What about `c` though? Does it represent any value? Maybe. It can be the symbol of the speed of light, for example. It can also be the constant of integration. Or even the length of a hypotenuse in the sense of a Pythagorean theorem. There are many possibilities. **You cannot choose the right one without some additional knowledge.** And this is the clue: `123` is a literal, and `c` is not. You use literals **to encode data and to put them into your code**.
- operator: symbol of the programming language, which is able to operate on the values.
- expressions: formed when data and operators are connected together. The simplest expression is a literal itself.
- variable: **comes into existence as a result of assigning a value to it**
    - Remove variable when it only has one purpose: Note that in the program that you can see in the editor, the `hypo` variable is used for only one purpose ‒ to save the calculated value between the execution of the adjoining line of code. As the `print()` function accepts an expression as its argument, you can **remove the variable** from the code.]
    - they are called *scalar* when they store exactly one given value at a time
- comment: a remark inserted into the program, which is ommited at runtime. Used to describe each important piece of code (e.g. by explaining the role of the variables) or marking fragments of code that aren't currently needed for whatever reason.
- type casting: type conversions
- nesting: using an if statement inside of another if statement or having a list inside of a list
- loop's body: an instruction or set of instructions executed inside a loop 
- multi-line printing: using triple quotes to print strings on multiple lines in order to make text easier to read, or create a special text-based design.
- **syntactic candy**/sugar: additions, which don't improve the language's expressive power, but only simplify the developer's work. Example: `continue` and `break`
- `continue` statement
- control variable: by default on `for` loops but optional on `while`
- *sorting*: processing like printing items from the smallest to the largest
- list: **a type of data** in Python used to **store multiple objects**, a very dynamic entity. It is an **ordered and mutable collection** of comma-separated items between square brackets.
- index/indices: The value inside the brackets which selects one element of the list
- *indexing*: operation of selecting an element from the list

---
#### How to read Python:
> ```Python
> var = 1
> print(var)
> var = var + 1
> print(var)
> ```
> - The first line of the snippet creates a new variable named `var` and assigns `1` to it.
> - The statement reads: assign a value of `1` to a variable named `var`.
> - We can say it shorter: assign `1` to `var`.
> - Some prefer to read such a statement as: `var` becomes `1`.
> - The third line **assigns the same variable with the new value taken** from the variable itself, summed with `1`. Seeing a record like that, a mathematician would probably protest ‒ no value may be equal to itself plus one. This is a contradiction. But Python treats the sign `=` not as *equal to*, but as *assign a value*.
> - Take the current value of the variable `var`, add `1` to it and store the result in the variable `var`.
> - In effect, the value of variable `var` has been incremented by one, which has nothing to do with comparing the variable with any value.

> `function_name(argument)`
> - First, Python checks if the name specified is legal (it browses its internal data in order to find an existing function of the name; if this search fails, Python aborts the code)
> - second, Python checks if the function's requirements for the number of arguments allows you to invoke the function in this way (e.g., if a specific function demands exactly two arguments, any invocation delivering only one argument will be considered erroneous, and will abort the code's execution)
> - third, Python leaves your code for a moment and jumps into the function you want to invoke; of course, it takes your argument(s) too and passes it/them to the function;
> - fourth, the function executes its code, causes the desired effect (if any), evaluates the desired result(s) (if any) and finishes its task;
> - finally, Python returns to your code (to the place just after the invocation) and resumes its execution.

> ```Python
> print("Tell me anything...")
> anything = input()
> print("Hmm...", anything, "... Really?") 
> ```
> It shows a very simple case of using the `input()` function.
> 
> Note:
> - The program **prompts the user to input some data** from the console (most likely using a keyboard, although it is also possible to input data using voice or image);
> - the `input()` function is invoked without arguments (this is the simplest way of using the function); the function will **switch the console to input mode**; you'll see a blinking cursor, and you'll be able to input some keystrokes, finishing off by hitting the _Enter_ key; all the inputted data will be **sent to your program** through the function's result;
> - note: you need to assign the result to a variable; this is crucial ‒ missing out this step will cause the entered data to be lost;
> - then we use the `print()` function to output the data we get, with some additional remarks.

> ```Python
> anything = input("Tell me anything...")
> print("Hmm...", anything, "...Really?") 
> ```
> Note:
> - the `input(`) function is invoked with one argument ‒ it's a string containing a message;
> - the message will be displayed on the console before the user is given an opportunity to enter anything;
> - `input()` will then do its job.
> This variant of the `input()` invocation simplifies the code and makes it clearer.

> ``` python
> if true_or_not:
>     do_this_if_true 
> ```
> 
> This conditional statement consists of the following, strictly necessary, elements in this and this order only:
> 
> - the `if` keyword;
> - one or more white spaces;
> - an expression (a question or an answer) whose value will be interpreted solely in terms of `True` (when its value is non-zero) and `False` (when it is equal to zero);
> - a **colon** followed by a newline;
> - an **indented** instruction or set of instructions (at least one instruction is absolutely required); the **indentation** may be achieved in two ways – by inserting a particular number of spaces (the recommendation is to use **four spaces of indentation**), or by using the _tab_ character; note: if there is more than one instruction in the indented part, the indentation should be the same in all lines; even though it may look the same if you use tabs mixed with spaces, it's important to make all indentations **exactly the same** – Python 3 **does not allow the mixing of spaces and tabs** for indentation.
> 
> How does that statement work?
> 
> - If the `true_or_not` expression **represents the truth** (i.e., its value is not equal to zero), **the indented statement(s) will be executed**;
> - if the `true_or_not` expression **does not represent the truth** (i.e., its value is equal to zero), **the indented statement(s) will be omitted** (ignored), and the next executed instruction will be the one after the original indentation level.
> 
> In real life, we often express a desire:
> 
> _if the weather is good, we'll go for a walk_
> _then, we'll have lunch_
> 
> As you can see, having lunch is **not a conditional activity** and doesn't depend on the weather.
> 
> Knowing what conditions influence our behavior, and assuming that we have the parameterless functions `go_for_a_walk()` and `have_lunch()`, we can write the following snippet:
> ```python
> if the_weather_is_good:
>     go_for_a_walk()
> have_lunch()
> ```

> If a certain sleepless Python developer falls asleep when he or she counts 120 sheep, and the sleep-inducing procedure may be implemented as a special function named `sleep_and_dream()`, the whole code takes the following shape:
> ```python
> if sheep_counter >= 120: # Evaluate a test expression
>     sleep_and_dream() # Execute if test expression is True` 
> ```
> You can read it as: if `sheep_counter` is greater than or equal to 120, then fall asleep and dream (i.e., execute the `sleep_and_dream function`.)

> We can say, for example: _If the weather is good, we will go for a walk, otherwise we will go to a theater_.
>
> Now we know what we'll do **if the conditions are met**, and we know what we'll do **if not everything goes our way**. In other words, we have a "Plan B".
> 
> Python allows us to express such alternative plans. This is done with a second, slightly more complex form of the conditional statement, the _if-else_ statement:
> ```python
> if true_or_false_condition:
>     perform_if_condition_true
> else:
>     perform_if_condition_false
> ```
> Thus, there is a new word: `else` – this is a **keyword**.
> 
> The part of the code which begins with `else` says what to do if the condition specified for the `if` is not met (note the **colon** after the word).
> 
> The _if-else_ execution goes as follows:
> 
> - if the condition evaluates to **True** (its value is not equal to zero), the `perform_if_condition_true` statement is executed, and the conditional statement comes to an end;
> - if the condition evaluates to **False** (it is equal to zero), the `perform_if_condition_false` statement is executed, and the conditional statement comes to an end.
>
> By using this form of conditional statement, we can describe our plans as follows:
> 
> ```python
> if the_weather_is_good:
>     go_for_a_walk()
> else:
>     go_to_a_theater()
> have_lunch()
> ```
> If the weather is good, we'll go for a walk. Otherwise, we'll go to a theater. No matter if the weather is good or bad, we'll have lunch afterwards (after the walk or after going to the theater).

> Read what we have planned for this Sunday. If the weather is fine, we'll go for a walk. If we find a nice restaurant, we'll have lunch there. Otherwise, we'll eat a sandwich. If the weather is poor, we'll go to the theater. If there are no tickets, we'll go shopping in the nearest mall.
>
> Let's write the same in Python. Consider carefully the code here:
> ```python
> if the_weather_is_good:
>     if nice_restaurant_is_found:
>         have_lunch()
>     else:
>         eat_a_sandwich()
> else:
>     if tickets_are_available:
>         go_to_the_theater()
>     else:
>         go_shopping()
> ```

> `elif` is used to **check more than just one condition**, and to **stop** when the first statement which is true is found.
> 
> Our next example resembles nesting, but the similarities are very slight. Again, we'll change our plans and express them as follows: If the weather is fine, we'll go for a walk, otherwise if we get tickets, we'll go to the theater, otherwise if there are free tables at the restaurant, we'll go for lunch; if all else fails, we'll stay home and play chess.
> 
> Have you noticed how many times we've used the word _otherwise_? This is the stage where the `elif` keyword plays its role.
> 
> Let's write the same scenario using Python:
> 
> ```python
> if the_weather_is_good:
>     go_for_a_walk()
> elif tickets_are_available:
>     go_to_the_theater()
> elif table_is_available:
>     go_for_lunch()
> else:
>     play_chess_at_home()
> ```

> Actually, the for loop is designed to do more complicated tasks – **it can "browse" large collections of data item by item**. We'll show you how to do that soon, but right now we're going to present a simpler variant of its application.
> 
> Take a look at the snippet:
> 
> ```python
> for i in range(100):
>     # do_something()
>     pass
> ```
> 
> There are some new elements. Let us tell you about them:
> 
> - the _for_ keyword opens the `for` loop; note – there's no condition after it; you don't have to think about conditions, as they're checked internally, without any intervention;
> - any variable after the _for_ keyword is the **control variable** of the loop; it counts the loop's turns, and does it automatically;
> - the _in_ keyword introduces a syntax element describing the range of possible values being assigned to the control variable;
> - the `range()` function (this is a very special function) is responsible for generating all the desired values of the control variable; in our example, the function will create (we can even say that it will **feed** the loop with) subsequent values from the following set: 0, 1, 2 .. 97, 98, 99; note: in this case, the `range()` function starts its job from 0 and finishes it one step (one integer number) before the value of its argument;
> - note the _pass_ keyword inside the loop body – it does nothing at all; it's an **empty instruction** – we put it here because the `for` loop's syntax demands at least one instruction inside the body (by the way – `if`, `elif`, `else` and `while` express the same thing)

> Let's create a variable called numbers; it's assigned with not just one number, but is filled with a list consisting of five values (note: the **list starts with an open square bracket and ends with a closed square bracket**; the space between the brackets is filled with five numbers separated by commas).
> 
> ```
> numbers = [10, 5, 7, 2, 1] 
> ```
> 
> Let's say the same thing using adequate terminology: **numbers is a list consisting of five values, all of them numbers**. We can also say that this statement creates a list of length equal to five (as in there are five elements inside it).

> The `for` loop has a special variant that can **process lists** very effectively ‒ let's take a look at that.
> 
> ```python
> my_list = [10, 1, 8, 3, 5]
> total = 0
> 
> for i in range(len(my_list)):
>     total += my_list[i]
> 
> print(total)
> 
> ```
> 
> Let's assume that you want to **calculate the sum of all the values stored in the `my_list` list**.
> 
> You need a variable whose sum will be stored and initially assigned a value of `0` ‒ its name will be `total`. (Note: we're not going to name it `sum` as Python uses the same name for one of its built-in functions: `sum()`. **Using the same name would generally be considered bad practice**.) Then you add to it all the elements of the list using the `for` loop. Take a look at the snippet in the editor.
> 
> Let's comment on this example:
> 
> - the list is assigned a sequence of five integer values;
> - the i variable takes the values `0`, `1`,` 2`, `3`, and `4`, and then it indexes the list, selecting the subsequent elements: the first, second, third, fourth and fifth;
> - each of these elements is added together by the `+=` operator to the `total` variable, giving the final result at the end of the loop;
> - note the way in which the `len()` function has been employed ‒ it makes the code independent of any possible changes in the list's contents.

> But the `for` loop can do much more. It can hide all the actions connected to the list's indexing, and deliver all the list's elements in a handy way.
> 
> This modified snippet shows how it works:
> 
> ```python
> my_list = [10, 1, 8, 3, 5]
> total = 0
> 
> for i in my_list:
>     total += i
> 
> print(total)
> 
> ```
> 
> What happens here?
> 
> - the `for` instruction specifies the variable used to browse the list (`i` here) followed by the `in` keyword and the name of the list being processed (`my_list` here)
> - the `i` variable is assigned the values of all the subsequent list's elements, and the process occurs as many times as there are elements in the list;
> - this means that you use the `i` variable as a copy of the elements' values, and you don't need to use indices;
> - the `len()` function is not needed here, either.

> Now you can easily **swap** the list's elements to **reverse their order:**
> 
> ```python
> my_list = [10, 1, 8, 3, 5]
> 
> my_list[0], my_list[4] = my_list[4], my_list[0]
> my_list[1], my_list[3] = my_list[3], my_list[1]
> 
> print(my_list)
> ```
> 
> Run the snippet. Its output should look like this:
> 
> ```Output
> [5, 3, 8, 1, 10]
> ```
> 
> It looks fine with five elements.
> 
> Will it still be acceptable with a list containing 100 elements? No, it won't.
> 
> Can you use the `for` loop to do the same thing automatically, irrespective of the list's length? Yes, you can.
> 
> This is how we've done it:
> 
> ```python
> for i in range(length // 2):
>     my_list[i], my_list[length - i - 1] = my_list[length - i - 1], my_list[i]
> 
> print(my_list)
> ```
> 
> Note:
> 
> - we've assigned the `length` variable with the current list's length (this makes our code a bit clearer and shorter)
> - we've launched the `for` loop to run through its body `length // 2 times` (this works well for lists with both even and odd lengths, because when the list contains an odd number of elements, the middle one remains untouched)
> - we've swapped the ith element (from the beginning of the list) with the one with an index equal to `(length - i - 1)` (from the end of the list); in our example, for `i` equal to `0` the `(length - i - 1)` gives `4`; for `i` equal to `1`, it gives `3` ‒ this is exactly what we needed.

---
## Examples

```python
# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))

# Choose the larger number
if number1 > number2:
    larger_number = number1
else:
    larger_number = number2

# Print the result
print("The larger number is:", larger_number)

```

```python
# Read three numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))

# We temporarily assume that the first number
# is the largest one.
# We will verify this soon.
largest_number = number1

# We check if the second number is larger than the current largest_number
# and update the largest_number if needed.
if number2 > largest_number:
    largest_number = number2

# We check if the third number is larger than the current largest_number
# and update the largest_number if needed.
if number3 > largest_number:
    largest_number = number3

# Print the result
print("The largest number is:", largest_number)

```

```python
# Store the current largest number here.
largest_number = -999999999

# Input the first value.
number = int(input("Enter a number or type -1 to stop: "))

# If the number is not equal to -1, continue.
while number != -1:
    # Is number larger than largest_number?
    if number > largest_number:
        # Yes, update largest_number.
        largest_number = number
    # Input the next number.
    number = int(input("Enter a number or type -1 to stop: "))

# Print the largest number.
print("The largest number is:", largest_number)

```

```python
largest_number = -99999999
counter = 0

while True:
    number = int(input("Enter a number or type -1 to end the program: "))
    if number == -1:
        break
    counter += 1
    if number > largest_number:
        largest_number = number

if counter != 0:
    print("The largest number is", largest_number)
else:
    print("You haven't entered any number.")

```

```python
largest_number = -99999999
counter = 0

number = int(input("Enter a number or type -1 to end program: "))

while number != -1:
    if number == -1:
        continue
    counter += 1

    if number > largest_number:
        largest_number = number
    number = int(input("Enter a number or type -1 to end the program: "))

if counter:
    print("The largest number is", largest_number)
else:
    print("You haven't entered any number.")

```

```python
# A program that reads a sequence of numbers
# and counts how many numbers are even and how many are odd.
# The program terminates when zero is entered.

odd_numbers = 0
even_numbers = 0

# Read the first number.
number = int(input("Enter a number or type 0 to stop: "))

# 0 terminates execution.
while number != 0:
    # Check if the number is odd.
    if number % 2 == 1:
        # Increase the odd_numbers counter.
        odd_numbers += 1
    else:
        # Increase the even_numbers counter.
        even_numbers += 1
    # Read the next number.
    number = int(input("Enter a number or type 0 to stop: "))

# Print results.
print("Odd numbers count:", odd_numbers)
print("Even numbers count:", even_numbers)

```

```python
counter = 5
while counter != 0:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)

```

```python
counter = 5
while counter:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)

```

```python
i = 1
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)
```

```python
i = 5
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)
```

```python
for i in range(5):
    print(i)
else:
    print("else:", i)
```

```python
i = 111
for i in range(2, 1):
    print(i)
else:
    print("else:", i)
```

```python
n = 3
 
while n > 0:
    print(n + 1)
    n -= 1
else:
    print(n)
```

```python
n = range(4)
 
for num in n:
    print(num - 1)
else:
    print(num)
```

```python
my_list = []  # Creating an empty list.

for i in range(5):
    my_list.append(i + 1)

print(my_list)
```

```python
my_list = []  # Creating an empty list.

for i in range(5):
    my_list.insert(0, i + 1)

print(my_list)
```

