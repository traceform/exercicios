#### Computers are binary:
The name 'boolean' comes from George Boole (1815-1864), the author of the fundamental work, _The Laws of Thought_, which contains the definition of **Boolean algebra** ‒ a part of algebra which makes use of only two distinct values: `True` and `False`, denoted as `1` and `0`.

A programmer writes a program, and the program asks questions. Python executes the program, and provides the answers. The program must be able to react according to the received answers.

Fortunately, computers know only two kinds of answers:

- Yes, this is true;
- No, this is false.

You'll never get a response like: _I don't know_ or _Probably yes, but I don't know for sure_.

#### Language:
1. Alphabet
2. Lexis
3. Syntax
4. Semantics

#### Actions that form a Program:
1. Input
2. Processing
3. Output

#### Compilation vs Interpretation
1. COMPILATION
- Doesn't need compiler to work
- Usually faster, but can't be easily edited
- May take time to fully compile
- Source code is hidden from the user and can't be shared easily as it needs to be compiled for each kind of architecture

2. INTERPRETATION
- Needs interpreter to work
- Usually slower than compiled because the computer resources are shared among the source program and the interpreter itself
- Happens instantly, line by line
- Source code is easily shareable and works anywhere there is a interpreter

#### Python is:
- a high-level programming language with dynamic semantics
- an interpreted programming language
- object-oriented
- used for general-purpose programming
- easy and intuitive, understandable, suitable for everyday tasks
- easy to learn, teach, use, understand, obtain

#### Python Data Types:
- Integers
- Floats
- Strings
- Boolean values
- None: is a `NoneType` object, and it is used to represent **the absence of a value**

### Keywords:
#### Known:
```known
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

'False', 'True' - boolean values
'None' - Null equivalent in python
'and', 'or', 'not' - logical operators
'in', 'is' - ?
'if', 'elif', 'else' - conditions
'while', 'for', 'break', 'continue' - loops
'def', 'return' - functions
'import', 'from', 'as' - working with modules and libraries
'try', 'except', 'finally', 'raise' - validation
'with', 'as' - working with files
```

#### Need to learn
'assert', 'class', 'del', 'global', 'lambda', 'nonlocal', 'pass', 'yield'

#### Operators:
- Basic: `**`; unary `+`, unary `-`; `*`, `/`, `//`, `%`; binary `+`, binary `-`
- Assignment: '='
- Shortcut: `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`

### Functions:
#### A function may:
1. cause some effect. Ex.: print()
2. or evaluate a value. Ex.: sqrt()
- have parameters to accept (positional/keyword) arguments

#### Known
`print()`, `round()`, `input()`, `int()`, `float()`, `str()`

#### Cool things to keep in mind:
- `print()` can handle octals and hexadecimals
- `0.4` can be written as `.4` and `4.0` can be written as `4.` because you can omit zero when it is the only digit in front of or after the decimal point
- `300000000` or `3 x 10⁸` scientific notation is written as `3e8` or `3E8` in Python. Ex.: `6.62607E-34`
    - Note: the exponent (the value after the E) has to be an integer; the base (the value in front of the E) may be either an integer or a float.
- `print('I\'m Monty Python.')` or `print("I'm Monty Python.")`
- `6 // 3` equals `2` (integer) because only when an integer is divided by an integer with `//` (integer/floor division) it results in an integer. Any regular divisions (`/`) or a floor division involving a float operand WILL result in a float because anything involving a float results in a float, even addition, subtraction, multiplication and exponentiation. Even an integer exponentiation may result in a float: `4 ** -1` equals `0.25`. However, for `//`, anything after the floating point becomes `0`. Ex.: `10 / 3` equals 3.333... but `10 // 3` equals `3`
- `%` (Remainder/Modulo) always results in a integer (or a float with `.0` if either operand is a float) because it results the remainder left after the integer division
```
+-------------------+------------------+--------------------+---------------------+----------------------+
| OPERATION         | INT & INT        | INT & FLOAT        | FLOAT & INT         | FLOAT & FLOAT        |
+-------------------+------------------+--------------------+---------------------+----------------------+
| Addition          | 1 + 1 = 2        | 1 + 1.0 = 2.0       | 1.5 + 1 = 2.5      | 1.5 + 1.0 = 2.5      |
| Subtraction       | 1 - 1 = 0        | 1 - 1.0 = 0.0       | 1.5 - 1 = 0.5      | 1.5 - 1.0 = 0.5      |
| Multiplication    | 2 * 2 = 4        | 2 * 2.0 = 4.0       | 2.5 * 2 = 5.0      | 2.5 * 2.0 = 5.0      |
| Division          | 2 / 2 = 1.0      | 2 / 2.0 = 1.0       | 2.5 / 2 = 1.25     | 2.5 / 2.0 = 1.25     |
| Floor Division    | 2 // 2 = 1       | 2 // 2.0 = 1.0      | 2.5 // 2 = 1.0     | 2.5 // 2.0 = 1.0     |
| Modulo            | 12 % 5 = 2       | 12 % 4.5 = 3.0      | 12.0 % 5 = 2.0     | 12.5 % 4.5 = 3.5     |
| Exponentiation    | 4 ** 2 = 16      | 4 ** 2.0 = 16.0     | 4.5 ** 2 = 20.25   | 4.5 ** 2.0 = 20.25   |
+-------------------+------------------+--------------------+---------------------+----------------------+
| Extra             | 4 ** -1 = 0.25                                                                     |
+-------------------+------------------------------------------------------------------------------------+
```

| OPERATION        | INT & INT        | INT & FLOAT        | FLOAT & INT         | FLOAT & FLOAT       |
|------------------|------------------|--------------------|---------------------|---------------------|
| Addition         | 1 + 1 = 2        | 1 + 1.0 = 2.0      | 1.5 + 1 = 2.5       | 1.5 + 1.0 = 2.5     |
| Subtraction      | 1 - 1 = 0        | 1 - 1.0 = 0.0      | 1.5 - 1 = 0.5       | 1.5 - 1.0 = 0.5     |
| Multiplication   | 2 * 2 = 4        | 2 * 2.0 = 4.0      | 2.5 * 2 = 5.0       | 2.5 * 2.0 = 5.0     |
| Division         | 2 / 2 = 1.0      | 2 / 2.0 = 1.0      | 2.5 / 2 = 1.25      | 2.5 / 2.0 = 1.25    |
| Floor Division   | 2 // 2 = 1       | 2 // 2.0 = 1.0     | 2.5 // 2 = 1.0      | 2.5 // 2.0 = 1.0    |
| Modulo           | 12 % 5 = 2       | 12 % 4.5 = 3.0     | 12.0 % 5 = 2.0      | 12.5 % 4.5 = 3.5    |
| Exponentiation   | 4 ** 2 = 16      | 4 ** 2.0 = 16.0    | 4.5 ** 2 = 20.25    | 4.5 ** 2.0 = 20.25  |
| Extra            | 4 ** -1 = 0.25   |                    |                     |                     |


- `2 % 4` equals 2 because 2 - 4 * (2 // 4) = 2 - 4 * 0 = 2 - 0 = 2
- `2 % -4` equals -2 because 2 - (-4) * (2 // -4) = 2 - (-4) * -1.0 = 2 - 4 = -2
- `9 ** 0.5` evaluates the square root of 9
- `9 * 0.1` evaluates 10% of 9
- `9 * 1.1` evaluates 9 + 10% of 9
- `input()` can be used without an argument
- `2 == 2.` | `2. == 2` is True
- Data Types and boolean values:
```Python
print(
f'''Integer: 1 - {bool(1)} | 0 - {bool(0)} | -1 - {bool(-1)}
Floating point: 1.0 - {bool(1.0)} | 0.0 - {bool(0.0)} | 0.1 - {bool(0.1)} | -1.0 - {bool(-1.0)}
String: 'Test' - {bool('Test')} | '' - {bool('')} | '0' - {bool('0')}
NoneType: None - {bool(None)}
List: [0, 0.0, '', False] - {bool([0, 0.0, '', False])} | [] - {bool([])}
Tuple: (0, 0.0, '', False) - {bool((0, 0.0, '', False))} | () - {bool(())}
Set: {{0, 0.0, '', False}} - {bool({0, 0.0, '', False})} | {{}} - {bool({})} | set() - {bool(set())}
''')

a = False
if a is not None:
    print(f"{a} is not NULL")
if a:
    print(f"{a} is not NULL, nor EMPTY (e.g.: '', 0, 0.0, False)")

```

#### Best practices:
- Comments: Comments are very important. They are used not only to make your programs **easier to understand**, but also to **disable those pieces of code that are currently not needed** (e.g., when you need to test some parts of your code only, and ignore others).
- Variable names: Whenever possible and justified, you should give self-commenting names to variables, e.g., if you're using two variables to store the length and width of something, the variable names `length` and `width` may be a better choice than `myvar1` and `myvar2`.
- It's good to **describe** each important piece of code with comments, use **self-commenting** and **readable** (non-confusing) variable names, and sometimes it's better to **divide your code** into named pieces (e.g., functions). In some situations, it's a good idea to write the steps of computations in a clearer way.

#### Remember:
- function:
    - positional argument: arguments passed in the positional way which means the meaning of the argument is dictated by its position
    - keyword argument:
        - the meaning of these arguments is taken not from its loation (position) but from the special word (keyword) used to identify them
        - it consists of three elements: a **keyword** identifying the argument; an **equal sign** and a **value** assigned to the argument. Any keyword arguments have to be put **after the last positional argument**
- literal: data whose values are determined by the literal itself. Ex.: `123` vs `c`. `123` is *one hundred twenty three*. What about `c` though? Does it represent any value? Maybe. It can be the symbol of the speed of light, for example. It can also be the constant of integration. Or even the length of a hypotenuse in the sense of a Pythagorean theorem. There are many possibilities. **You cannot choose the right one without some additional knowledge.** And this is the clue: `123` is a literal, and `c` is not. You use literals **to encode data and to put them into your code**.
- operator: symbol of the programming language, which is able to operate on the values.
- expressions: formed when data and operators are connected together. The simplest expression is a literal itself.
- variable: **comes into existence as a result of assigning a value to it**
    - Remove variable when it only has one purpose: Note that in the program that you can see in the editor, the `hypo` variable is used for only one purpose ‒ to save the calculated value between the execution of the adjoining line of code. As the `print()` function accepts an expression as its argument, you can **remove the variable** from the code.
- comment: a remark inserted into the program, which is ommited at runtime. Used to describe each important piece of code (e.g. by explaining the role of the variables) or marking fragments of code that aren't currently needed for whatever reason.
- type casting: type conversions


#### How to read Python:
> ```Python
> var = 1
> print(var)
> var = var + 1
> print(var)
> ```
> - The first line of the snippet creates a new variable named `var` and assigns `1` to it.
> - The statement reads: assign a value of `1` to a variable named `var`.
> - We can say it shorter: assign `1` to `var`.
> - Some prefer to read such a statement as: `var` becomes `1`.
> - The third line **assigns the same variable with the new value taken** from the variable itself, summed with `1`. Seeing a record like that, a mathematician would probably protest ‒ no value may be equal to itself plus one. This is a contradiction. But Python treats the sign `=` not as *equal to*, but as *assign a value*.
> - Take the current value of the variable `var`, add `1` to it and store the result in the variable `var`.
> - In effect, the value of variable `var` has been incremented by one, which has nothing to do with comparing the variable with any value.

> `function_name(argument)`
> - First, Python checks if the name specified is legal (it browses its internal data in order to find an existing function of the name; if this search fails, Python aborts the code)
> - second, Python checks if the function's requirements for the number of arguments allows you to invoke the function in this way (e.g., if a specific function demands exactly two arguments, any invocation delivering only one argument will be considered erroneous, and will abort the code's execution)
> - third, Python leaves your code for a moment and jumps into the function you want to invoke; of course, it takes your argument(s) too and passes it/them to the function;
> - fourth, the function executes its code, causes the desired effect (if any), evaluates the desired result(s) (if any) and finishes its task;
> - finally, Python returns to your code (to the place just after the invocation) and resumes its execution.

> ```Python
> print("Tell me anything...")
> anything = input()
> print("Hmm...", anything, "... Really?") 
> ```
> It shows a very simple case of using the `input()` function.
> 
> Note:
> - The program **prompts the user to input some data** from the console (most likely using a keyboard, although it is also possible to input data using voice or image);
> - the `input()` function is invoked without arguments (this is the simplest way of using the function); the function will **switch the console to input mode**; you'll see a blinking cursor, and you'll be able to input some keystrokes, finishing off by hitting the _Enter_ key; all the inputted data will be **sent to your program** through the function's result;
> - note: you need to assign the result to a variable; this is crucial ‒ missing out this step will cause the entered data to be lost;
> - then we use the `print()` function to output the data we get, with some additional remarks.

> ```Python
> anything = input("Tell me anything...")
> print("Hmm...", anything, "...Really?") 
> ```
> Note:
> - the `input(`) function is invoked with one argument ‒ it's a string containing a message;
> - the message will be displayed on the console before the user is given an opportunity to enter anything;
> - `input()` will then do its job.
> This variant of the `input()` invocation simplifies the code and makes it clearer.



